#include <stdio.h>
#include <stdlib.h>
#include <graphics.h>
#include <time.h>
#include <math.h>

#define byte unsigned char
#define word unsigned short

class layer{
private:
	char name[20];
	double **data;
	double *bias;
public:
	byte row, col;
	layer(){
		strcpy_s(name, "temp");
		row = col = 1;
		data = new double*[row];
		for (byte i = 0; i < row; i++){
			data[i] = new double[col];
			for (byte j = 0; j < col; j++){
				data[i][j] = 1;
			}
		}
	}
	layer(FILE *fp){
		fscanf_s(fp, "%d %d %s", &row, &col, name);
		printf("%d %d %s\n", row, col, name);
		data = new double*[row];
		bias = new double[row];
		for (byte i = 0; i < row; i++){
			data[i] = new double[col];
			for (byte j = 0; j < col; j++){
				fscanf_s(fp, "%lf", &data[i][j]);
			}
			fscanf_s(fp, "%lf", &bias[i]);
		}
	}
	layer(byte row, byte col){
		strcpy_s(name, "temp");
		this->row = row;
		this->col = col;
		this->data = new double*[row];
		for (byte i = 0; i < row; i++){
			data[i] = new double[col];
			for (byte j = 0; j < col; j++){
				if (i == j)data[i][j] = 1.0f;
				else data[i][j] = 0.0f;
			}
		}
	}
	layer(const layer &a){
		strcpy_s(name, a.name);
		row = a.row, col = a.col;
		data = new double*[row];
		for (byte i = 0; i < row; i++){
			data[i] = new double[col];
			for (byte j = 0; j < col; j++){
				data[i][j] = a.data[i][j];
			}
		}
	}
	~layer(){
		// 删除原有数据
		for (byte i = 0; i < row; i++){
			delete[]data[i];
		}
		delete[]data;
	}
	layer& operator =(const layer &a){
		strcpy_s(name, a.name);
		// 删除原有数据
		for (byte i = 0; i < row; i++){
			delete[]data[i];
		}
		delete[]data;
		// 重新分配空间
		row = a.row, col = a.col;
		data = new double*[row];
		for (byte i = 0; i < row; i++){
			data[i] = new double[col];
			for (byte j = 0; j < col; j++){
				data[i][j] = a.data[i][j];
			}
		}
		return *this;
	}
	layer operator ~()const{
		layer arr(col, row);
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				arr.data[j][i] = data[i][j];
			}
		}
		return arr;
	}
	layer operator *(const layer &b){
		layer arr(row, col);
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				arr.data[i][j] = data[i][j] * b.data[i][j];
			}
		}
		return arr;
	}
	layer operator *(const int b){
		layer arr(row, col);
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				arr.data[i][j] = b * data[i][j];
			}
		}
		return arr;
	}
	layer operator ()(const layer &b){
		layer arr(row, b.col);
		for (byte k = 0; k < b.col; k++){
			for (byte i = 0; i < row; i++){
				arr.data[i][k] = 0;
				for (byte j = 0; j < col; j++){
					arr.data[i][k] += data[i][j] * b.data[j][k];
				}
			}
		}
		return arr;
	}
	layer operator -(const layer &b){
		layer arr(row, col);
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				arr.data[i][j] = data[i][j] - b.data[i][j];
			}
		}
		return arr;
	}
	layer operator +(const layer &b){
		layer arr(row, col);
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				arr.data[i][j] = data[i][j] + b.data[i][j];
			}
		}
		return arr;
	}
	layer neg(){
		layer arr(row, col);
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				arr.data[i][j] = -data[i][j];
			}
		}
		return arr;
	}
	bool operator ==(const layer &a){
		bool result = true;
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				if (abs(data[i][j] - a.data[i][j]) > 10e-6){
					result = false;
					break;
				}
			}
		}
		return result;
	}
	bool overflow(){
		bool result = false;
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				if (data[i][j] > 10e8 || data[i][j] < 10e-8){
					result = true;
					break;
				}
			}
		}
		return result;
	}
	void randomize(){
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				data[i][j] = (double)(rand() % 1000) / 1000;
			}
		}
	}
	void print(){
		printf("%d %d %s\n", row, col, name);
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				printf("%lf ", data[i][j]);
			}
			printf("\n");
		}
	}
	double mo(){
		double v = 0;
		for (byte i = 0; i < row; i++){
			for (byte j = 0; j < col; j++){
				v += data[i][j] * data[i][j];
			}
		}
		return sqrt(v / row / col);
	}
};

class network{
	int iter;
	layer arr[5];
	layer data, target;
	layer nonlin(layer &x, bool deriv){
		if (deriv){
			layer e(x.row, x.col);
			return x * (e - x);// 误差函数
		}
		double m = 1 / (1 + exp(x.mo()));// 1/(1+ e^-i)
		return x * m;
	}
public:
	network(FILE *fp){
		srand(time(0));
		fscanf_s(fp, "%d", &iter);
		data = layer(fp);
		for (byte i = 0; i < 5; i++){
			arr[i] = layer(fp);
			arr[i].randomize();
		}
		target = layer(fp);
	}
	void train(){
		int i = 0;
		printf("Training network\n");
		printf("Training...\n");
		for (i = 0; i < iter; i++){
			printf("Iterate:%4d\n", i);
			// 正向传播
			layer l0 = data;
			layer l1 = nonlin(arr[0](l0), false);
			layer l2 = nonlin(arr[1](l1), false);
			layer l3 = nonlin(arr[2](l2), false);
			layer l4 = nonlin(arr[3](l3), false);
			layer l5 = nonlin(arr[4](l4), false);
			if (l5 == target){
				printf("exit because taining results is equals to target.\n");
				break;
			}
			// 反向传播
			layer l5_error = (target - l5);// [1 4] = [1 4] - [1 4]
			layer l5_delta = l5_error * nonlin(l5, true);
			layer l4_error = (~arr[4])(l5_delta);// [4 4] = [4 1] . [1 4]
			layer l4_delta = l4_error * nonlin(l4, true);
			layer l3_error = (~arr[3])(l4_delta);// [5 4] = [5 4] . [4 4]
			layer l3_delta = l3_error * nonlin(l3, true);
			layer l2_error = (~arr[2])(l3_delta);// [6 4] = [6 5] . [5 4]
			layer l2_delta = l2_error * nonlin(l2, true);
			layer l1_error = (~arr[1])(l2_delta);// [5 4] = [5 6] . [6 4]
			layer l1_delta = l1_error * nonlin(l1, true);
			// 输出错误
			printf("Training errors\n");
			l1_error.print();
			l2_error.print();
			l3_error.print();
			l4_error.print();
			l5_error.print();
			// 输出误差
			printf("Training deltas\n");
			l1_delta.print();
			l2_delta.print();
			l3_delta.print();
			l4_delta.print();
			l5_delta.print();
			// 计算新的权值
			arr[4] = arr[4] + l5_delta(~l4);// [1 4] = [1 4] + [1 4](~[4 4])
			arr[3] = arr[3] + l4_delta(~l3);// [4 5] = [4 5] + [4 4](~[5 4])
			arr[2] = arr[2] + l3_delta(~l2);// [5 6] = [5 6] + [5 4](~[6 4])
			arr[1] = arr[1] + l2_delta(~l1);// [6 5] = [6 5] + [6 4](~[5 4])
			arr[0] = arr[0] + l1_delta(~l0);// [5 8] = [5 8] + [5 4](~[8 4])
		}
		printf("Training complete\n");
	}
	void test(){
		printf("test network\n");
		data.print();
		// 正向传播
		layer l0 = data;
		layer l1 = nonlin(arr[0](l0), false);
		layer l2 = nonlin(arr[1](l1), false);
		layer l3 = nonlin(arr[2](l2), false);
		layer l4 = nonlin(arr[3](l3), false);
		layer l5 = nonlin(arr[4](l4), false);
		l5.print();
	}
	void print(){
		printf("print network\n");
		data.print();
		for (byte i = 0; i < 5; i++){
			arr[i].print();
		}
		target.print();
	}
};